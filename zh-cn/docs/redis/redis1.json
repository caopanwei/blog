{
  "filename": "redis1.md",
  "__html": "<h1>Redis从基础到进阶</h1>\n<h2>1.Redis介绍及入门</h2>\n<h3>1.1 Redis是什么?</h3>\n<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API\n1，Redis安装在磁盘；\n2，Redis数据存储在内存。</p>\n<h3>1.2Redis特性</h3>\n<p>redis是一种基于键值对（key-value）数据库，其中value可以为string、hash、list、set、zset等多种数据结构，可以满足很多应用场景。还提供了键过期，发布订阅，事务，流水线等附加功能.<br>\n特性：<br>\n1〉速度快<br>\n2〉键值对的数据结构服务器<br>\n3〉丰富的功能：<br>\n4〉简单稳定<br>\n5〉持久化<br>\n6〉主从复制<br>\n8〉高可用和分布式转移<br>\n9〉客户端语言多</p>\n<h3>1.3使用场景</h3>\n<p>1，缓存数据库<br>\n2，排行榜<br>\n3，计数器应用<br>\n4，社交网络<br>\n5，消息队列</p>\n<h3>1.4Redis安装</h3>\n<p>此处不在详细编写,可直接百度</p>\n<h3>1.5Redis配置、启动、操作、关闭</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">可执行文件</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">redis-server</td>\n<td style=\"text-align:center\">启动redis</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-cli</td>\n<td style=\"text-align:center\">redis命令行客户端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-benchmark</td>\n<td style=\"text-align:center\">基准测试工具</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-check-aof</td>\n<td style=\"text-align:center\">AOF持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-check-dump</td>\n<td style=\"text-align:center\">RDB持久化文件检测和修复工具</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-sentinel</td>\n<td style=\"text-align:center\">启动哨兵</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">redis-trib</td>\n<td style=\"text-align:center\">cluster集群构建工具</td>\n</tr>\n</tbody>\n</table>\n<h2>2.Redis数据结构及常用命令</h2>\n<h3>2.1数据结构-字符串(String)</h3>\n<p>字符串类型：实际上可以是字符串（包括XML JSON），还有数字（整形 浮点数），二进制（图片 音频 视频），最大不能超过512MB.</p>\n<h4>设值命令</h4>\n<p>set age 23 ex 10  //10秒后过期  px 10000 毫秒过期<br>\nsetnx name test  //不存在键name时，返回1设置成功；存在的话失败0<br>\nset age 25 xx      //存在键age时，返回1成功</p>\n<h4>获值命令</h4>\n<p>get age //存在则返回value, 不存在返回null<br>\n批量设值：mset country china city beijing<br>\n批量获取：mget country city address //返回china  beigjin, address为nil</p>\n<h4>计数</h4>\n<p>incr age //必须为整数自加1，非整数返回错误，无age键从0自增返回1<br>\ndecr age //整数age减1<br>\nincrby age 2 //整数age+2<br>\ndecrby age 2//整数age -2<br>\nincrbyfloat score 1.1 <a href=\"//xn--score+1-js9lu04n44g.1\">//浮点型score+1.1</a></p>\n<h4>追加</h4>\n<p>append追加指令：<br>\nset name hello; append name world //追加后成helloworld<br>\n字符串长度：<br>\nset hello “世界”；strlen hello//结果6，每个中文占3个字节<br>\n截取字符串：<br>\nset name helloworld ; getrange name 2 4//返回 llo</p>\n<h3>2.2数据结构-哈希(hash)</h3>\n<p>哈希hash是一个string类型的field和value的映射表，hash特适合用于存储对象<br>\n命令  hset key field value<br>\n设值：hset user:1 name james         //成功返回1，失败返回0<br>\n取值：hget user:1 name              //返回james<br>\n删值：hdel user:1 age               //返回删除的个数<br>\n计算个数：hset user:1 name james; hset user:1 age 23;<br>\nhlen user:1  //返回2，user:1有两个属性值<br>\n批量设值：hmset user:2 name james age 23 sex boy //返回OK<br>\n批量取值：hmget user:2 name age sex  //返回三行：james 23 boy<br>\n判断field是否存在：hexists user:2 name //若存在返回1，不存在返回0<br>\n获取所有field: hkeys user:2    // 返回name age sex三个field<br>\n获取user:2所有value：hvals user:2     // 返回james 23 boy<br>\n获取user:2所有field与value：hgetall user:2 //name age sex james 23 boy值<br>\n增加1：hincrby user:2 age 1      //age+1<br>\nhincrbyfloat user:2 age 2   //浮点型加2</p>\n<p>使用hash类型存储数据<br>\nhmset user:1 name james age 23 sex boy\n优点：简单直观，使用合理可减少内存空间消耗\n缺点：要控制ziplist与hashtable两种编码转换，且hashtable会消耗更多内存erialize(userInfo);</p>\n<h3>2.3数据结构-列表(list)</h3>\n<p>用来存储多个有序的字符串，一个列表最多可存2的32次方减1个元素\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-153505@2x.png\" alt=\"\">\n因为有序，可以通过索引下标获取元素或某个范围内元素列表，\n列表元素可以重复</p>\n<h4>添加命令：</h4>\n<p>rpush james c b a //从右向左插入cba, 返回值3<br>\nlrange james 0 -1 //从左到右获取列表所有元素 返回 c b a<br>\nlpush key c b a //从左向右插入cba<br>\nlinsert james before b teacher //在b之前插入teacher, after为之后，使用lrange james 0 -1 查看：c teacher b a</p>\n<h4>查找命令：</h4>\n<p>lrange key start end //索引下标特点：从左到右为0到N-1<br>\nlindex james -1 //返回最右末尾a，-2返回b<br>\nllen james        //返回当前列表长度<br>\nlpop james       //把最左边的第一个元素c删除<br>\nrpop james      //把最右边的元素a删除</p>\n<h3>2.4数据结构-集合(Set)</h3>\n<p>用户标签，社交，查询有共同兴趣爱好的人,智能推荐\n保存多元素，与列表不一样的是不允许有重复元素，且集合是无序，一个集合最多可存2的32次方减1个元素，除了支持增删改查，还支持集合交集、并集、差集；\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-153849@2x.png\" alt=\"\"></p>\n<p>exists user    //检查user键值是否存在<br>\nsadd user a b c//向user插入3个元素，返回3<br>\nsadd user a b  //若再加入相同的元素，则重复无效，返回0<br>\nsmember user //获取user的所有元素,返回结果无序<br>\nsrem user a   //返回1，删除a元素<br>\nscard user    //返回2，计算元素个数</p>\n<h3>2.5数据结构-有序集合(Zset)</h3>\n<p>常用于排行榜，如视频网站需要对用户上传视频做排行榜，或点赞数\n与集合有联系，不能有重复的成员\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-154121@2x.png\" alt=\"\"></p>\n<h4>命令</h4>\n<p>指令：<br>\nzadd key score member [score member......]<br>\nzadd user:zan 200 james //james的点赞数1, 返回操作成功的条数1<br>\nzadd user:zan 200 james 120 mike 100 lee// 返回3<br>\nzadd test:1 nx 100 james   //键test:1必须不存在，主用于添加<br>\nzadd test:1 xx incr 200 james   //键test:1必须存在，主用于修改,此时为300<br>\nzadd test:1 xx ch incr -299 james //返回操作结果1，300-299=1<br>\nzrange test:1 0 -1 withscores  //查看点赞（分数）与成员名<br>\nzcard test:1     //计算成员个数， 返回1<br>\n排名场景：<br>\nzadd user:3 200 james 120 mike 100 lee//先插入数据<br>\nzrange user:3 0 -1 withscores //查看分数与成员<br>\nzrank user:3 james  //返回名次：第3名返回2，从0开始到2，共3名<br>\nzrevrank user:3 james //返回0， 反排序，点赞数越高，排名越前</p>\n<h4>应用场景</h4>\n<p>排行榜系统，如视频网站需要对用户上传的视频做排行榜<br>\n点赞数：<br>\nzadd user:1:20180106 3 mike  //mike获得3个赞<br>\n再获一赞：<br>\nzincrby user:1:20180106 1 mike  //在3的基础上加1<br>\n用户作弊，将用户从排行榜删掉：<br>\nzrem user:1:20180106 mike<br>\n展示赞数最多的5个用户：<br>\nzrevrangebyrank user:1:20180106  0  4<br>\n查看用户赞数与排名：<br>\nzscore user:1:20180106 mike   zrank user:1:20180106 mike</p>\n<h4>与LIST和SET对比</h4>\n<p><img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-154307@2x.png\" alt=\"\"></p>\n<h3>2.6Redis全局命令</h3>\n<p>1，查看所有键：<br>\nkeys *   set school enjoy   set hello world<br>\n2，键总数 ：<br>\ndbsize       //2个键，如果存在大量键，线上禁止使用此指令<br>\n3，检查键是否存在：<br>\nexists key  //存在返回1，不存在返回0<br>\n4，删除键：<br>\ndel key      //del hello school, 返回删除键个数，删除不存在键返回0<br>\n5，键过期：<br>\nexpire key seconds        //set name test<br>\nexpire name 10,表示10秒过期<br>\nttl key                            // 查看剩余的过期时间<br>\n6，键的数据结构类型：<br>\ntype key //type hello     //返回string,键不存在返回none</p>\n<h3>2.7Redis数据库管理</h3>\n<p>select 0    选择第一个数据库<br>\nflushdb     清空当前数据库数据<br>\nflushall    清空所有数据库数据<br>\ndbsize      返回当前数据库Key的数量</p>\n<h2>3.Redis持久化</h2>\n<p>redis是一个支持持久化的内存数据库,也就是说redis需要经常将内存中的数据同步到磁盘来保证持久化，持久化可以避免因进程退出而造成数据丢失.<br>\nredis持久化有两种方式 RDB和AOF.</p>\n<h3>3.1RDB持久化</h3>\n<h4>原理</h4>\n<p>RDB持久化把当前进程数据生成快照（.rdb）文件保存到硬盘的过程，有手动触发和自动触发.<br>\n手动触发有save和bgsave两命令<br>\nsave命令：阻塞当前Redis，直到RDB持久化过程完成为止，若内存实例比较大会造成长时间阻塞，线上环境不建议用它<br>\nbgsave命令：redis进程执行fork操作创建子线程，由子线程完成持久化，阻塞时间很短（微秒级），是save的优化,在执行redis-cli shutdown关闭redis服务时，如果没有开启AOF持久化，自动执行bgsave;<br>\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-160510@2x.png\" alt=\"\"></p>\n<h4>操作</h4>\n<p>命令：config set dir /usr/local  //设置rdb文件保存路径<br>\n备份：bgsave  <a href=\"//xn--dump-fw9g.xn--rdbusr-rd0ju2nz0y/local%E4%B8%8B\">//将dump.rdb保存到usr/local下</a><br>\n恢复：将dump.rdb放到redis安装目录与redis.conf同级目录，重启redis即可<br>\n优点：<br>\n1，压缩后的二进制文，适用于备份、全量复制，用于灾难恢复<br>\n2，加载RDB恢复数据远快于AOF方式<br>\n缺点：\n1，无法做到实时持久化，每次都要创建子进程，频繁操作成本过高<br>\n2，保存后的二进制文件，存在老版本不兼容新版本rdb文件的问题</p>\n<h3>3.2AOF持久化</h3>\n<p>针对RDB不适合实时持久化，redis提供了AOF持久化方式来解决<br>\n开启：redis.conf设置：appendonly yes  (默认不开启，为no)<br>\n默认文件名：appendfilename &quot;appendonly.aof&quot;</p>\n<h4>原理</h4>\n<p>流程说明：<br>\n1，所有的写入命令(set hset)会append追加到aof_buf缓冲区中<br>\n2，AOF缓冲区向硬盘做sync同步<br>\n3，随着AOF文件越来越大，需定期对AOF文件rewrite重写，达到压缩<br>\n4，当redis服务重启，可load加载AOF文件进行恢复<br>\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-161424@2x.png\" alt=\"\">\n命令写入(append), 文件同步(sync), 文件重写(rewrite), 重启加载(load)</p>\n<h4>配置详解</h4>\n<p>appendonly yes           //启用aof持久化方式<br>\n// appendfsync always //每收到写命令就立即强制写入磁盘，最慢的，但是保证完全的持久化，不推荐使用<br>\nappendfsync everysec //每秒强制写入磁盘一次，性能和持久化方面做了折中，推荐<br>\n// appendfsync no         //完全依赖os，性能最好,持久化没保证（操作系统自身的同步）<br>\nno-appendfsync-on-rewrite  yes  //正在导出rdb快照的过程中,要不要停止同步aof<br>\nauto-aof-rewrite-percentage 100  //aof文件大小比起上次重写时的大小,增长率100%时,重写<br>\nauto-aof-rewrite-min-size 64mb   //aof文件,至少超过64M时,重写</p>\n<h4>AOF存储方式</h4>\n<p>AOF文件存储使用RESP协议\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-163822@2x.png\" alt=\"\"></p>\n<h4>AOF如何恢复</h4>\n<ol>\n<li>设置appendonly yes；</li>\n<li>将appendonly.aof放到dir参数指定的目录；</li>\n<li>启动Redis，Redis会自动加载appendonly.aof文件。</li>\n</ol>\n<h3>3.3Redis重启时加载AOF与RDB的顺序？</h3>\n<p>1，当AOF和RDB文件同时存在时，优先加载AOF<br>\n2，若关闭了AOF，加载RDB文件<br>\n3，加载AOF/RDB成功，redis重启成功<br>\n4，AOF/RDB存在错误，启动失败打印错误信息<br>\n<img src=\"https://gitee.com/cpw/commonimage/raw/master/QQ20190420-161920@2x.png\" alt=\"\"></p>\n",
  "link": "/zh-cn/docs/redis/redis1.html",
  "meta": {}
}